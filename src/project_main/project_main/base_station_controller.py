import time
import sys
import random
import numpy as np

import rclpy
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor

from std_msgs.msg import String
from rosgraph_msgs.msg import Clock

from sim_utils import EventScheduler

NUMBER_OF_SENSORS = int(sys.argv[1])

WORLD_NAME = "iot_project_world"

REQUEST_TS = 6 # value used to keep coherence between possible requests and time passing
class BaseStationController(Node):

    def __init__(self):
        super().__init__("base_station_controller")

        self.event_scheduler = EventScheduler()
        self.clock_topic = self.create_subscription(
            Clock,
            f'/world/{WORLD_NAME}/clock',
            self.event_scheduler.routine,
            10
        )

        # topic to receive responses to requests
        self.rx_data = self.create_subscription(
            String,
            '/base_station/rx_data',
            self.rx_callback,
            10
        )

        # topic to publish requests to balloons (via the simulation manager)
        self.requests = self.create_publisher(
            String,
            '/base_station/requests',
            NUMBER_OF_SENSORS*3 # send 3 requests per sensor
        )

        # send a group of requests every 6 seconds
        self.event_scheduler.schedule_event(REQUEST_TS, self.send_requests)

        # used to handle the range of timestamp to be queried  
        self.timestamp = 0              

        # used to increment the timestamp in accordance with the sending rate of requests  
        self.increment_range = REQUEST_TS

    # starting from the timestamp considered, pick 3 timestamps to create 3 requests
    # based on poisson distribution with a lambda=1 to avoid unrealstic requests
    def generate_poisson_requests(self, timestamp, id):
        requests = []
        rate = 1 
        for i in range(3):

            ### Version for different sensors generating data at different frequencies 
            # timestamp = int(timestamp - timestamp*(id/(id+1)))
            ###

            ts = timestamp + np.random.poisson(1/rate)
            if ts > 0 and f"{id}_{ts}" not in requests:
                requests.append(f"{id}_{ts}")
        return requests

    # pick 3 timestamps to create 3 requests
    # based on gaussian distribution with the mean centered on the timestamp
    # timestamp is always 6 seconds (REQUEST_TS) behind the current timestamps generated by the balloons
    # in this way requests are not unrealtisc and cover a good interval
    def generate_gaussian_requests(self, timestamp, id):
        requests = []
        std_dev = 2.7
        mean = timestamp

        ### Version for different sensors generating data at different frequencies 
        # mean = int(timestamp - timestamp*(id/(id+1)))
        ###

        for i in range(3):
            ts = int(np.random.normal(mean, std_dev))
            if ts > 0 and f"{id}_{ts}" not in requests:
                requests.append(f"{id}_{ts}")
        return requests
    
    # ick 3 timestamps to create 3 requests
    # based on a pseudo-random distribution over an interval of size = 2*REQUEST_TS
    def generate_pseudorandom_requests(self,timestamp, id):
        requests = []
        increment_range = self.increment_range
        for i in range(3):

            ### Version for different sensors generating data at different frequencies 
            # timestamp = int(timestamp - timestamp*(id/(id+1)))
            # increment_range = int(increment_range - increment_range*(id/(id+1)))
            ###

            ts = int(np.random.uniform(timestamp - increment_range, timestamp + increment_range))
            msg = String()
            msg.data = f"{id}_{ts}"
            if ts > 0 and f"{id}_{ts}" not in requests:
                requests.append(f"{id}_{ts}")
        return requests

    def one_third(self):
        return NUMBER_OF_SENSORS//3
    
    # divide sensors in three groups, each associated with a different random distribution
    def send_requests(self):
        requests = []
        if(NUMBER_OF_SENSORS < 3):
            requests.extend(self.generate_gaussian_requests(self.timestamp, 0))
            if(NUMBER_OF_SENSORS == 2):
                requests.extend(self.generate_pseudorandom_requests(self.timestamp, 1))
        else:
            one_third = self.one_third()
            ## requests for the first third of sensors (poisson distribution)
            for i in range(one_third):
                requests.extend(self.generate_poisson_requests(self.timestamp, i))
            ## requests for the second third of sensors (normal distribution)
            for i in range(one_third, 2*one_third):
                requests.extend(self.generate_gaussian_requests(self.timestamp, i))
            ## requests for the third third of sensors (random distribution)
            for i in range(2*one_third, NUMBER_OF_SENSORS):
                requests.extend(self.generate_pseudorandom_requests(self.timestamp, i))

        # publish requests
        for req in requests:
            msg = String()
            msg.data = f"{req}"
            self.requests.publish(msg)
        self.timestamp += self.increment_range
        

    def rx_callback(self, msg):
        self.get_logger().info(msg.data)


def main():
    rclpy.init()

    base_station_controller = BaseStationController()
    executor = MultiThreadedExecutor()
    executor.add_node(base_station_controller)

    executor.spin()
    executor.shutdown()
    base_station_controller.destroy_node()
    rclpy.shutdown()
